import math

def baby_step_giant_step(g, h, p):
    """
    Алгоритм большого и малого шага для решения дискретного логарифма:
    находит число x, удовлетворяющее равенству g^x ≡ h (mod p),
    где p — простое число, g — генератор (основание), h — значение.

    Идея:
        Дискретный логарифм — это "обратная" операция к возведению в степень по модулю.
        Решить g^x = h (mod p) напрямую трудно, но этот алгоритм
        эффективнее полного перебора.

    Как работает:
        1. Выбираем m ≈ √p — размер шага.
        2. Считаем "малые шаги": для j в [0, m-1] вычисляем g^j (mod p) и сохраняем в словарь.
        3. Вычисляем обратный множитель factor = g^(-m) (mod p).
        4. Выполняем "большие шаги": для i в [0, m-1] вычисляем gamma = h * factor^i (mod p)
           и проверяем, есть ли gamma среди "малых шагов".
        5. Если нашли совпадение, то x = i*m + j — искомый логарифм.

    Параметры:
        g (int): основание (генератор) по модулю p
        h (int): результат возведения g^x (mod p)
        p (int): простое число, модуль

    Возвращает:
        int или None: значение x, если решение найдено, иначе None

    Пример:
        baby_step_giant_step(3, 13, 17) вернёт 4, потому что 3^4 ≡ 13 (mod 17)
    """
    m = math.isqrt(p) + 1  # Округляем вверх квадратный корень из p
    # Предварительно считаем и сохраняем все g^j mod p для j в [0, m)
    baby_steps = {pow(g, j, p): j for j in range(m)}

    # Вычисляем обратный множитель: g^(-m) mod p (для "больших шагов")
    factor = pow(g, -m, p)

    gamma = h  # Начинаем с h

    for i in range(m):
        if gamma in baby_steps:  # Проверяем, встретилось ли gamma в "малых шагах"
            # Если да, возвращаем индекс x = i*m + j
            return i * m + baby_steps[gamma]
        # Иначе делаем следующий "большой шаг"
        gamma = (gamma * factor) % p

    # Если решение не найдено — возвращаем None
    return None


# Пример:
print("log₃(13) по модулю 17 =", baby_step_giant_step(3, 13, 17))  # Ожидаемый ответ: 4

# Дополнительные тесты:
print("log₂(15) по модулю 23 =", baby_step_giant_step(2, 15, 23))  # Проверка: 2^x = 15 mod 23
print("log₅(8) по модулю 23 =", baby_step_giant_step(5, 8, 23))    # Проверка: 5^x = 8 mod 23
input() # Для того, чтобы программа не закрывалась сразу
