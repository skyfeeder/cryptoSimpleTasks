def egcd(a, b):
    """
    Расширенный алгоритм Евклида.
    Находит НОД (наибольший общий делитель) чисел a и b,
    а также числа x и y, такие что: a*x + b*y = НОД(a, b).

    Возвращает кортеж (g, x, y), где g = gcd(a, b).

    Пример:
        egcd(30, 20) вернёт (10, 1, -1), потому что 30*1 + 20*(-1) = 10
    """
    if a == 0:
        return b, 0, 1
    g, y, x = egcd(b % a, a)  # Рекурсивный вызов
    return g, x - (b // a) * y, y


def modinv(a, m):
    """
    Находит обратный элемент к числу a по модулю m,
    то есть число x, такое что (a*x) % m = 1.

    Использует расширенный алгоритм Евклида.

    Если обратного элемента не существует (НОД не равен 1), выбрасывает исключение.

    Пример:
        modinv(3, 11) вернёт 4, потому что (3*4) % 11 = 12 % 11 = 1
    """
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('Обратного элемента не существует')
    return x % m


def rsa_sign(m, d, n):
    """
    Создаёт цифровую подпись сообщения m с помощью закрытого ключа (d, n).

    Формула: s = m^d mod n

    m - сообщение (число)
    d - секретная часть ключа
    n - произведение двух простых чисел

    Возвращает подпись s.
    """
    return pow(m, d, n)


def rsa_verify(m, s, e, n):
    """
    Проверяет цифровую подпись s для сообщения m
    с помощью открытого ключа (e, n).

    Проверка: m == s^e mod n

    Возвращает True, если подпись валидна, иначе False.
    """
    return m == pow(s, e, n)


# Пример

# Выбираем простые числа p и q
p, q = 61, 53
n = p * q               # Модуль
phi = (p - 1) * (q - 1) # Функция Эйлера

e = 17                  # Открытая экспонента (обычно выбирается так, чтобы gcd(e, phi)=1)
d = modinv(e, phi)      # Закрытая экспонента - обратный элемент к e по модулю phi

message = 42            # Сообщение (число) для подписи

signature = rsa_sign(message, d, n)  # Создаём подпись

print("Подпись:", signature)

# Проверяем подпись
print("Проверка подписи:", rsa_verify(message, signature, e, n))  # True, если всё правильно



# Дополнительные примеры:

# Пример 1: обратный элемент по модулю
print("Обратный элемент к 7 по модулю 26:", modinv(7, 26))  # Ожидается 15

# Пример 2: расширенный алгоритм Евклида
g, x, y = egcd(99, 78)
print(f"НОД(99, 78) = {g}, x = {x}, y = {y} (проверка: 99*{x} + 78*{y} = {g})")

input() # Для того, чтобы программа не закрывалась сразу