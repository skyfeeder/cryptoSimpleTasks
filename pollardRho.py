import math
import random

def gcd(a, b):
    """
    Вычисляет наибольший общий делитель (НОД) двух целых чисел a и b
    с помощью алгоритма Евклида.

    Алгоритм основан на том, что НОД(a, b) равен НОД(b, a % b), и повторяет
    этот процесс до тех пор, пока одно из чисел не станет нулём.
    Оставшееся ненулевое значение — это и есть НОД.

    Пример:
        gcd(48, 18) → 6
        gcd(101, 10) → 1 (взаимно простые числа)

    Параметры:
        a (int): первое число
        b (int): второе число

    Возвращает:
        int: наибольший общий делитель чисел a и b
    """
    while b: a, b = b, a % b
    return a

def pollard_rho(n):
    """Метод Полларда для факторизации
    Метод Полларда "ρ" (ро) — вероятностный алгоритм для разложения составного
    числа n на множители. Особенно эффективен для чисел, имеющих малые делители.

    Идея метода:
        - Используется псевдослучайная функция f(x) = x^2 + c (mod n)
        - Последовательность значений x вычисляется по этой функции
        - Ищется два числа x и y, такие что их разность делится на общий делитель с n
        - Вычисляется НОД(x - y, n). Если это не 1 и не n, найден нетривиальный делитель.

    Метод называется "ρ" (ро) из-за того, что последовательность значений часто
    визуально напоминает греческую букву ро (ρ), когда значения начинают повторяться.

    Пример:
        Для n = 8051 (8051 = 83 * 97), алгоритм может вернуть 97 или 83.

    Параметры:
        n (int): составное число, которое требуется разложить на множители

    Возвращает:
        int: найденный нетривиальный делитель числа n

    Важно:
        Метод работает вероятностно. Если не получилось найти делитель с первой попытки,
        можно запустить снова (например, с другим значением c или начальной точкой x).
    """
    if n % 2 == 0:
        return 2
    x = random.randint(2, n - 1) # Начальная точка
    y = x # Второй указатель для "черепаха и зайца"
    c = random.randint(1, n - 1) # Константа в функции f(x) = x^2 + c
    d = 1 # Начальное значение НОД
    while d == 1:
        # Движение "черепахи": один шаг
        x = (pow(x, 2, n) + c) % n
        # Движение "зайца": два шага
        y = (pow(y, 2, n) + c) % n
        y = (pow(y, 2, n) + c) % n
        # Вычисляем НОД разности
        d = gcd(abs(x - y), n)
    return d


def pollard_rho_verbose(n, c=1, x0=1, max_iter=100):
    """
    Версия метода Полларда "ро" с подробным выводом по итерациям.
    n — факторизуемое число
    c — константа в f(x) = x^2 + c
    x0 — начальное значение
    max_iter — максимум итераций
    """
    def f(x): return (x * x + c) % n

    a = x0
    b = x0
    print(f"{'i':<3}{'a':<10}{'b':<10}{'НОД(a-b,n)':<12}")
    d = 1
    i = 0
    print(f"{i:<3}{a:<10}{b:<10}{d:<12}")
    while d == 1 and i < max_iter:
        a = f(a)
        b = f(f(b))
        d = math.gcd(a - b, n)
        i += 1
        print(f"{i:<3}{a:<10}{b:<10}{d:<12}")
    if 1 < d < n:
        print(f"Нетривиальный делитель найден: {d}")
    elif d == n:
        print("Делитель не найден (d == n)")
    else:
        print("Делитель не найден за отведённое число итераций")

# Пример
#n = 8051
#print("Один из множителей:", pollard_rho(n))

# Пример использования:
n = 1359331
c = 5
x0 = 1
pollard_rho_verbose(n, c, x0)

input()  # Чтобы программа не закрывалась сразу
# в коде 2 функции: _verbose ← с выводом как было на лекции, СДАВАТЬ ЛУЧШЕ ОДНУ!
