def extended_gcd(a, b):
    """
    Расширенный алгоритм Евклида.

    Эта функция находит:
    - g = НОД(a, b) — наибольший общий делитель чисел a и b,
    - x, y — такие числа, что выполняется уравнение:
      a*x + b*y = g.

    Используется рекурсия: если b = 0, то gcd — это a, и x=1, y=0.
    Иначе функция вызывает сама себя с параметрами (b, a % b),
    и вычисляет новые x и y из результатов рекурсии.

    Это ключевой алгоритм для поиска обратного элемента по модулю.
    """
    if b == 0:
        return a, 1, 0  # Базовый случай: НОД(a,0)=a, x=1, y=0
    g, x1, y1 = extended_gcd(b, a % b)  # рекурсивный вызов
    # Пересчитываем x и y для текущего уровня рекурсии:
    return g, y1, x1 - (a // b) * y1

def mod_inverse(a, n):
    """
    Находит обратный элемент к a по модулю n, если он существует.

    Обратный элемент x — такое число, что (a * x) % n == 1.

    Для этого вызывается extended_gcd(a, n), которая возвращает
    gcd и коэффициенты x, y для уравнения Безу: a*x + n*y = gcd.

    Если gcd != 1, обратного элемента нет, и функция выбрасывает ошибку.
    Иначе возвращает x по модулю n.
    """
    g, x, _ = extended_gcd(a, n) # '_' - временная переменная
    if g != 1:
        raise ValueError(f"Обратного элемента не существует для {a} по модулю {n}")
    return x % n


# Пример:
a = 17
n = 125
print(f"Обратный элемент к {a} по модулю {n} — {mod_inverse(a, n)}")

# Дополнительные примеры для проверки:
print(f"Обратный элемент к 3 по модулю 11 — {mod_inverse(3, 11)}")  # ожидается 4
print(f"Обратный элемент к 10 по модулю 17 — {mod_inverse(10, 17)}")  # ожидается 12

input()  # Чтобы окно не закрылось сразу
